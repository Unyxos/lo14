#Nécessaire pour calcul droit
testrights()
{
	nb=0
	#echo "test : $1"
	if [[ $(echo $1 | grep "r") ]]
	then
		((nb=$nb+4))
		#echo "+4"
	fi
	if [[ $(echo $1 | grep "w") ]]
	then
		((nb=$nb+2))
		#echo "+2"
	fi
	if [[ $(echo $1 | grep "x") ]]
	then
		((nb=$nb+1))
		#echo "+1"
	fi
	echo $nb
}

#Fonction principale du calcul des droits des fichiers/dossiers
calculdroit{
if [ $# -eq 0 ]
then
	echo "Il n'y a pas d'argument"
else
	right=$1
	echo $line
	nbc=$(echo -n $right | wc -c)
	if [ $nbc -eq 9 ]
	then
		gp1=$(echo $right | sed 's/\(^...\).*/\1/')
		#echo "gp1 = $gp1"
		vgp1=$(testrights $gp1)
		#echo $vgp1

		gp2=$(echo $right | sed 's/^...\(...\).*/\1/')
		#echo "gp2 = $gp2"
		vgp2=$(testrights $gp2)
		#echo $vgp2

		gp3=$(echo $right | sed 's/.*\(...\)$/\1/')
		#echo "gp3 = $gp3"
		vgp3=$(testrights $gp3)
		#echo $vgp3

		((rights=$vgp1*100+$vgp2*10+$vgp3))
		echo $rights
	else
		echo "Les droits ne sont pas enregistrés correctement"
		echo "Veuillez les modifier au bon format"
	fi
fi
}





#Nécessaire pour la fonction extract
makefile()
{
#echo $2
touch extraction/$2
#echo "droit : $1"
#echo $(calculdroit $1)
somme=$(($3+$4-1))
if [ $4 -ne 0 ]
then
	cat body | head -n $somme | tail -n $4 > extraction/$2
else
	touch extraction/$2
fi
sudo chmod $(calculdroit $1) extraction/$2
}
#Nécessaire pour la fonction extract
makedir()
{
#echo "dir"
mkdir extraction/$2
#echo "droit : $1"
#echo $(calculdroit $1)
sudo chmod $(calculdroit $1) extraction/$2
}

#Fonction principale de l'extraction des fichiers et dossiers de l'archives dans le dossier extraction
extract(){
#Ici on vient récupérer l'arborescence racine contenant les dossiers 
#de l'archive (contenu dans la première ligne directory)
#Ensuite on créé les dossiers et on les place dans le bonne ordre.
root_dir=$(cat header | head -n 1 | cut -d' ' -f2 | sed 's/\(.*\)\/$/\1/')
#echo $root_dir
mkdir -p extraction/$root_dir

while read ligne
do
if [[ $ligne =~ ^[^d] ]] && [[ $ligne =~ ^[^@] ]]
then
	#emier caractère du paquets de droit afin de déterminer si on a un dossier ou un fichier
	dir=$(echo $ligne | cut -d ' ' -f2 | sed 's/^\(.\).*$/\1/g')
	#on récupère le gro
	#on récupère le prupe de droit sans le premier carctère
	rig=$(echo $ligne | cut -d ' ' -f2 | sed 's/^.\(.*\)/\1/g')
	#on récupère le nom du fichier
	name=$(echo $ligne | cut -d ' ' -f1)
	case $dir in
		-)#echo "c'est un ficier"
		#on récupère le caractère marquant le début du contenu dans le body
		d=$(echo $ligne | cut -d' ' -f4)
		#on récupère le carctère marquant la longueur du contenu
		f=$(echo $ligne | cut -d' ' -f5)
		makefile $rig $name $d $f;;
		d)#echo "c'est un dossier"
		makedir $rig $name;;
		*)echo "gros ton archive est foutu";;
	esac
fi
done < header
}





#Fonction principale de "rangement" des fichiers extraits
placement(){
changement="false"
str=""
while read line
do
	if [ "$(echo -n $line)" == "@" ]
	then
		changement="false"	
		#echo $changement
		#appeler ici la fonction qui va bouger les fichiers dans les dossiers
		cd extraction
		
		for i in $str
		do
		
			if [ -f $i ]
			then
				echo $i
				mv $i $active_dir/$i
			fi
			
			if [ -d $i ]
			then 
				echo $i
				mv $i $active_dir/$i
			fi
			
		done
		
		cd ..
		echo "str : $str"
		str=""
	fi
	
	if [ $changement == "true" ]
	then
		#ici si la variable changement est à true on envoie le nom du fichier
		#dans la variable $str 
		str="$str $(echo $line | cut -d' ' -f1)"
		#echo "changement=true"
	fi
	
	if [ $(echo $line | cut -d' ' -f1) == "directory" ]
	then
		#ici si on se trouve sur une ligne qui commance par directory, elle va forcément indiquer
		#le nom du dossier et sa place dans l'arborescence
		#on vient donc récupérer le nom du dossier et le placer dans la variable $active_dir
		#sed 's/^.*\/\?\([A-Za-z0-9_]*\)\/$/a\1/'
		
		active_dir=$(echo $line | cut -d ' ' -f2)
		
		if [ $(echo $active_dir | sed 's/.*\(.\)$/\1/') == "/" ]
		then
			active_dir=$(echo $active_dir | sed 's/\(.*\).$/\1/')
		fi
		
		echo "dir : $active_dir"
		changement="true"
		#echo $changement
	fi
	
done < header
echo $str
}